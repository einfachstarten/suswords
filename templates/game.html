<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>SusWords ‚Äì Spiel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Rubik&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
    :root {
      --bg: #1d1b3a;
      --panel: #2c294d;
      --highlight: #00f0ff;
      --accent: #ffcc00;
      --danger: #ff3260;
      --success: #4bdc65;
      --text: #ffffff;
      --muted: #888;
    }

    body {
      background: var(--bg);
      font-family: 'Rubik', sans-serif;
      color: var(--text);
      margin: 0;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    .logo {
      display: block;
      margin: 0 auto 20px;
      max-width: 300px;
    }

    #playerNameBanner {
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      font-size: 1.8em;
      color: var(--highlight);
      margin-bottom: 20px;
    }

    section {
      background: var(--panel);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 0 10px var(--highlight);
    }

    input, button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      border: none;
      border-radius: 5px;
      font-size: 1em;
    }

    input {
      background: #1b1a2e;
      color: var(--text);
    }

    button {
      background: var(--highlight);
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }

    button:disabled {
      background: #555;
      color: #aaa;
      cursor: not-allowed;
    }

    #susAction {
      margin-top: 15px;
    }

    #susAction button {
      margin-bottom: 5px;
    }

    #susOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 9999;
      color: #fff;
      text-align: center;
    }

    #susText {
      font-size: 2.5em;
      margin-bottom: 20px;
      font-family: 'Orbitron', sans-serif;
      color: var(--danger);
    }

    .vote-btns button {
      font-size: 2em;
      padding: 20px;
      width: 120px;
      margin: 10px;
    }

    .vote-btns button:first-child {
      background: var(--success);
    }

    .vote-btns button:last-child {
      background: var(--danger);
    }

    .hidden {
      display: none;
    }

    #closeVote {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--accent);
      color: #000;
      padding: 5px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    #errorMessage {
      color: #ff5555;
      margin-top: 10px;
      font-weight: bold;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .vote-result {
      font-size: 1.5em;
      margin: 20px 0;
    }

    .word-counter {
      font-size: 0.8em;
      color: var(--muted);
      text-align: right;
      margin-top: 5px;
    }

    strike {
      color: var(--muted);
      text-decoration: line-through;
    }

    /* Game over screen styles */
    .game-over {
      text-align: center;
      padding: 30px;
      border-radius: 10px;
    }

    .game-over h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2em;
      margin-bottom: 20px;
    }

    .game-over p {
      font-size: 1.2em;
      margin-bottom: 15px;
    }

    .game-over button {
      background: var(--accent);
      margin-top: 20px;
      padding: 15px;
      font-size: 1.2em;
      max-width: 200px;
    }

    .success {
      box-shadow: 0 0 20px var(--success);
    }

    .danger {
      box-shadow: 0 0 20px var(--danger);
    }

    .warning {
      box-shadow: 0 0 20px var(--accent);
    }

    .status-error {
      color: var(--danger);
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      bottom: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      background: rgba(0, 0, 0, 0.5);
    }

    .status-connected {
      color: var(--success);
    }

    .status-polling {
      color: var(--accent);
    }

    .status-error {
      color: var(--danger);
    }

    /* Vote status styles */
    .vote-count {
      margin: 10px 0;
      font-size: 1.2em;
      color: var(--accent);
    }

    .vote-timer {
      margin-top: 20px;
      font-size: 1.2em;
      color: var(--text);
    }

    .vote-summary {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 10px;
      margin: 15px 0;
    }

    .vote-summary h3 {
      margin-top: 0;
      color: var(--highlight);
    }

    .voter-list {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      text-align: left;
    }

    .voter-list li {
      padding: 5px;
      border-bottom: 1px solid #444;
    }

    .voter-list .voted-up {
      color: var(--success);
    }

    .voter-list .voted-down {
      color: var(--danger);
    }

    .voter-list .not-voted {
      color: var(--muted);
    }

    .eliminated-player {
      color: var(--muted);
      text-decoration: line-through;
    }

    /* Simple notification instead of complex overlay */
    .game-notification {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--panel);
      color: var(--text);
      padding: 15px 30px;
      border-radius: 10px;
      box-shadow: 0 0 20px rgba(0, 240, 255, 0.5);
      z-index: 10000;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.2em;
      text-align: center;
      border: 2px solid var(--highlight);
      animation: slideInNotification 0.5s ease-out;
      max-width: 500px;
    }

    .game-notification.success {
      border-color: var(--success);
      box-shadow: 0 0 20px rgba(75, 220, 101, 0.5);
    }

    .game-notification.danger {
      border-color: var(--danger);
      box-shadow: 0 0 20px rgba(255, 50, 96, 0.5);
    }

    .game-notification.warning {
      border-color: var(--accent);
      box-shadow: 0 0 20px rgba(255, 204, 0, 0.5);
    }

    @keyframes slideInNotification {
      from {
        opacity: 0;
        transform: translateX(-50%) translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <img src="/static/suswords.png" alt="SusWords Logo" class="logo">
    <div id="playerNameBanner">Spieler: ...</div>

    <section id="gameSection">
      <div id="turnInfo">üéØ <b>Aktueller Spieler:</b> ‚Äì</div>
      <div id="status">üìù Geheimes Wort: ‚Äì</div>

      <div id="wordSection" class="hidden">
        <label for="hint">Dein Hinweiswort:</label>
        <input id="hint" placeholder="Dein Hinweiswort" maxlength="30">
        <div class="word-counter"><span id="charCount">0</span>/30</div>
        <div id="errorMessage" class="hidden"></div>
        <button id="submitBtn" disabled>üìù Abschicken</button>
        <div id="susAction"></div>
      </div>

      <div>
        <b>üìú History:</b>
        <ul id="historyList"></ul>
      </div>
    </section>
  </div>

  <div id="susOverlay">
    <div id="closeVote">X</div>
    <div id="susText">...</div>
    <div class="vote-btns">
      <button id="voteUpBtn" onclick="castVote('up')">üëç</button>
      <button id="voteDownBtn" onclick="castVote('down')">üëé</button>
    </div>
    <div id="voteTimer" class="vote-timer hidden">Zeit zum Abstimmen: 15s</div>
    <div id="voteSummary" class="vote-summary hidden">
      <h3>Abstimmung (<span id="votesCount">0/0</span> abgestimmt):</h3>
      <ul id="voterList" class="voter-list"></ul>
    </div>
    <div id="voteResult" class="vote-result hidden"></div>
  </div>

  <div id="connectionStatus" class="connection-status status-connected">
    Verbunden
  </div>

  <!-- Simple notification -->
  <div id="gameNotification" class="game-notification hidden">
    <div id="notificationText">Benachrichtigung</div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get("game_id");
    const playerId = urlParams.get("player_id");

    let playerName = "";
    let isImpostor = false;
    let isPolling = false;
    let isVoting = false;
    let gamePollingInterval = null;
    let votePollingInterval = null;
    let lastGameState = null;
    let currentSuspectId = null;
    let connectionStatus = "connected";
    let retryAttempts = 0;
    let maxRetryAttempts = 5;

    // Pr√ºfen, ob Game ID und Player ID vorhanden sind
    if (!gameId || !playerId) {
      document.getElementById("gameSection").innerHTML =
        "<div id='errorMessage'>Fehler: Game ID oder Player ID fehlt in der URL.</div>";
    } else {
      initGame();
    }

    async function initGame() {
      try {
        await lookupOwnPlayerName();
        await monitorGame();
        startGamePolling();
      } catch (err) {
        console.error("Fehler beim Initialisieren des Spiels:", err);
        document.getElementById("gameSection").innerHTML =
          `<div id='errorMessage'>Fehler beim Starten des Spiels: ${err.message}</div>`;
        updateConnectionStatus("error");
      }
    }

    function startGamePolling() {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      gamePollingInterval = setInterval(monitorGame, 3000);
    }

    function updateConnectionStatus(status) {
      const statusElem = document.getElementById("connectionStatus");
      connectionStatus = status;

      statusElem.className = "connection-status";
      switch (status) {
        case "connected":
          statusElem.classList.add("status-connected");
          statusElem.innerText = "Verbunden";
          break;
        case "polling":
          statusElem.classList.add("status-polling");
          statusElem.innerText = "Aktualisiere...";
          break;
        case "error":
          statusElem.classList.add("status-error");
          statusElem.innerText = "Verbindungsfehler";
          break;
      }
    }

    async function lookupOwnPlayerName() {
      try {
        updateConnectionStatus("polling");
        const res = await fetch(`/players_in_game/${gameId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();
        const player = data.players.find(p => p.player_id === playerId);

        if (!player) {
          throw new Error("Spieler nicht im Spiel gefunden");
        }

        playerName = player.name;
        document.getElementById("playerNameBanner").innerText = `üéÆ Spieler: ${playerName}`;
        updateConnectionStatus("connected");
        retryAttempts = 0;
        return data;
      } catch (err) {
        console.error("Fehler beim Abrufen des Spielernamens:", err);
        document.getElementById("playerNameBanner").innerHTML =
          `Spieler: <span style="color: #ff5555">Verbindungsfehler</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts <= maxRetryAttempts) {
          console.log(`Versuch ${retryAttempts}/${maxRetryAttempts}: Wiederverbinden in 5 Sekunden...`);
          setTimeout(lookupOwnPlayerName, 5000);
        }

        throw err;
      }
    }

    async function monitorGame() {
      if (isPolling) return;
      isPolling = true;
      updateConnectionStatus("polling");

      try {
        const res = await fetch(`/game_state/${gameId}/${playerId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();

        // Check for game end
        if (data.game_status === "finished") {
          showGameOverScreen(data);
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        // Check if player is eliminated
        if (data.status === "eliminated") {
          document.getElementById("gameSection").innerHTML =
            `<div id='errorMessage'>${data.message || "Du wurdest aus dem Spiel entfernt!"}</div>`;
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        if (!data || data.error) {
          throw new Error(data?.error || "Unbekannter Serverfehler");
        }

        lastGameState = data;

        try {
          const playersRes = await fetch(`/players_in_game/${gameId}`);
          if (!playersRes.ok) throw new Error(`Fehler beim Laden der Spielerliste: ${playersRes.status}`);
          const playersData = await playersRes.json();

          updateGameUI(data, playersData);

          // Handle active vote
          if (data.active_vote) {
            handleActiveVote(data);
          } else {
            // Clear vote polling if no active vote
            if (votePollingInterval) {
              clearInterval(votePollingInterval);
              votePollingInterval = null;
            }

            // Hide overlay if no active vote
            if (document.getElementById("susOverlay").style.display === "flex") {
              hideSusOverlay();
            }
          }

          updateConnectionStatus("connected");
          retryAttempts = 0;
        } catch (playersErr) {
          console.error("Fehler beim Laden der Spielerliste:", playersErr);
          updateGameUI(data, { players: [] });
          updateConnectionStatus("error");
        }
      } catch (err) {
        console.error("Fehler beim Aktualisieren des Spielstatus:", err);
        document.getElementById("status").innerHTML =
          `<span style="color: #ff5555">Verbindungsfehler: ${err.message}</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts > maxRetryAttempts) {
          console.log(`Zu viele fehlgeschlagene Versuche. Polling wird reduziert.`);
          if (gamePollingInterval) {
            clearInterval(gamePollingInterval);
            gamePollingInterval = setInterval(monitorGame, 10000);
          }
        }
      } finally {
        isPolling = false;
      }
    }

    function handleActiveVote(data) {
      console.log("handleActiveVote called with:", data.active_vote);

      // Check if overlay should be hidden
      if (data.active_vote.overlay_hidden) {
        hideSusOverlay();
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim L√∂schen des Votings:", err);
          }
        }, 500);
        return;
      }

      // Only show overlay for votes with substance
      const hasVotes = Object.keys(data.active_vote.votes || {}).length > 0;
      const hasResult = !!data.active_vote.result;

      if (!hasVotes && !hasResult) {
        console.log("Vote has no substance yet, not showing overlay");
        return;
      }

      const isPlayerSuspect = data.active_vote.suspect_id === playerId;
      currentSuspectId = data.active_vote.suspect_id;
      const initiatorName = data.active_vote.initiator_name || "Unbekannt";
      const suspectName = data.active_vote.suspect_name || "Unbekannt";

      // Show overlay if not already shown
      if (document.getElementById("susOverlay").style.display !== "flex") {
        console.log("Showing SUS overlay");
        const hasVoted = data.active_vote.votes && data.active_vote.votes[playerId];
        showSusOverlay(initiatorName, suspectName, isPlayerSuspect, hasVoted);
      }

      // Start vote polling if not already active
      if (!votePollingInterval) {
        votePollingInterval = setInterval(async () => {
          try {
            const voteRes = await fetch(`/vote_status/${gameId}/${playerId}`);
            if (!voteRes.ok) throw new Error(`Vote status error: ${voteRes.status}`);

            const voteData = await voteRes.json();
            if (voteData.active) {
              updateVoteDisplay(voteData);
            } else if (document.getElementById("susOverlay").style.display === "flex") {
              hideSusOverlay();
            }
          } catch (err) {
            console.error("Fehler beim Vote-Status:", err);
          }
        }, 1000);
      }
    }

    function updateVoteDisplay(voteData) {
      if (!voteData || !voteData.active) return;

      const upVotes = voteData.votes.up || 0;
      const downVotes = voteData.votes.down || 0;

      // Update vote count
      let countElement = document.querySelector(".vote-count");
      if (!countElement) {
        countElement = document.createElement("div");
        countElement.classList.add("vote-count");
        document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
      }
      countElement.innerHTML = `Stand der Abstimmung: üëç ${upVotes} vs üëé ${downVotes}`;

      // Update votes count text
      const votesCountElem = document.getElementById("votesCount");
      if (votesCountElem) {
        votesCountElem.textContent = `${voteData.votes_cast}/${voteData.votes_needed}`;
      }

      // Update voter list
      const voterList = document.getElementById("voterList");
      if (voterList) {
        voterList.innerHTML = "";
        const voters = voteData.voters || {};

        document.getElementById("voteSummary").classList.remove("hidden");

        Object.entries(voters).forEach(([voterId, voterInfo]) => {
          const li = document.createElement("li");
          const voteEmoji = voterInfo.vote === "up" ? "üëç" : "üëé";
          li.textContent = `${voterInfo.name}: ${voteEmoji}`;
          li.classList.add(voterInfo.vote === "up" ? "voted-up" : "voted-down");
          voterList.appendChild(li);
        });
      }

      // Handle vote result
      if (voteData.result) {
        console.log("Vote result detected:", voteData.result);

        document.getElementById("voteResult").classList.remove("hidden");
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteTimer").classList.add("hidden");

        const resultText = getVoteResultText(voteData.result);
        document.getElementById("voteResult").innerHTML =
          `${resultText} (üëç ${upVotes} vs üëé ${downVotes})`;

        // Show notification for important results
        if (["impostor_eliminated", "impostor_wins", "player_eliminated"].includes(voteData.result)) {
          showVoteResultNotification(voteData.result);
        }
      }

      // Handle overlay hidden
      if (voteData.overlay_hidden) {
        hideSusOverlay();
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim L√∂schen des Votings:", err);
          }
        }, 500);
      }
    }

    function showVoteResultNotification(result) {
      let message = "";
      let type = "success";

      switch (result) {
        case "impostor_eliminated":
          if (isImpostor) {
            message = "VERLOREN! Du wurdest als Impostor entlarvt!";
            type = "danger";
          } else {
            message = "GEWONNEN! Ihr habt den Impostor gefunden!";
            type = "success";
          }
          break;
        case "impostor_wins":
          if (isImpostor) {
            message = "GEWONNEN! Du hast als Impostor √ºberlebt!";
            type = "success";
          } else {
            message = "VERLOREN! Der Impostor hat √ºberlebt!";
            type = "danger";
          }
          break;
        case "player_eliminated":
          if (isImpostor) {
            message = "ERFOLG! Ein unschuldiger Spieler wurde entfernt!";
            type = "success";
          } else {
            message = "OH NEIN! Ein unschuldiger Spieler wurde entfernt!";
            type = "warning";
          }
          break;
      }

      if (message) {
        showGameNotification(message, type);
      }
    }

    function showGameOverScreen(data) {
      const isImpostor = data.your_role === "impostor";
      const impostorWon = data.winner === "impostor";
      const secretWord = data.word || data.your_word || "???";

      let message = "";
      let emoji = "";
      let colorClass = "";

      if (isImpostor) {
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Du hast das Wort erraten und gewonnen!";
            showGameNotification("GEWONNEN! Du hast das geheime Wort erraten!", "success");
          } else {
            message = "Du hast gewonnen! Die Spieler konnten dich nicht finden.";
            showGameNotification("GEWONNEN! Du hast alle anderen √ºberlebt!", "success");
          }
          emoji = "üèÜ";
          colorClass = "success";
        } else {
          message = "Game Over! Du wurdest entlarvt.";
          showGameNotification("VERLOREN! Du wurdest als Impostor entlarvt!", "danger");
          emoji = "üö´";
          colorClass = "danger";
        }
      } else {
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Game Over! Der Impostor hat das Wort erraten.";
            showGameNotification("VERLOREN! Der Impostor hat das Wort erraten!", "danger");
          } else {
            message = "Game Over! Der Impostor hat gewonnen.";
            showGameNotification("VERLOREN! Der Impostor hat √ºberlebt!", "danger");
          }
          emoji = "üíÄ";
          colorClass = "danger";
        } else {
          message = "Gratulation! Ihr habt den Impostor gefunden und das Spiel gewonnen!";
          showGameNotification("GEWONNEN! Der Impostor wurde enttarnt!", "success");
          emoji = "üèÜ";
          colorClass = "success";
        }
      }

      document.getElementById("gameSection").innerHTML = `
        <div class="game-over ${colorClass}">
          <h2>${emoji} Spiel beendet ${emoji}</h2>
          <p>${message}</p>
          <p>Das geheime Wort war: <strong>${secretWord}</strong></p>
        </div>
      `;
    }

    function updateGameUI(data, playersData) {
      const currentPlayer = data.current_player;
      const isMyTurn = currentPlayer === data.player_name;
      isImpostor = data.your_role === "impostor";

      document.getElementById("turnInfo").innerHTML =
        `üéØ <b>Aktueller Spieler:</b> ${currentPlayer || '-'}`;

      document.getElementById("status").innerHTML = isImpostor
        ? "üïµÔ∏è Du bist der Impostor! Versuche das Wort zu erraten."
        : `üî§ <b>Geheimes Wort:</b> ${data.your_word || '-'}`;

      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      document.getElementById("wordSection").classList.toggle("hidden", !isMyTurn);

      const playerMap = {};
      if (playersData && playersData.players) {
        playersData.players.forEach(p => playerMap[p.player_id] = p.name);
      }

      if (isMyTurn) {
        input.disabled = false;
        input.focus();
        updateSubmitButton();
        setupSusButtons(playersData.players || []);
      } else {
        input.disabled = true;
        btn.disabled = true;
        document.getElementById("susAction").innerHTML = "";
      }

      // Update history
      const historyContainer = document.getElementById("historyList");
      historyContainer.innerHTML = "";

      const eliminatedPlayers = data.eliminated_players || [];

      data.history.forEach(entry => {
        const li = document.createElement("li");
        const playerName = playerMap[entry.player_id] || entry.player_id;
        const isEliminated = eliminatedPlayers.includes(entry.player_id) ||
            playersData?.players?.find(p => p.player_id === entry.player_id)?.eliminated;

        if (isEliminated) {
          li.innerHTML = `<strike>${playerName}: ${entry.word}</strike>`;
          li.classList.add("eliminated-player");
        } else {
          li.textContent = `${playerName}: ${entry.word}`;
        }

        historyContainer.appendChild(li);
      });
    }

    // Function to retry clearing vote
    async function clearVoteWithRetry(maxRetries = 3) {
      let attempts = 0;

      while (attempts < maxRetries) {
        try {
          const res = await fetch("/clear_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_id: gameId })
          });

          if (!res.ok) throw new Error(`Server error: ${res.status}`);

          console.log("Vote successfully cleared");
          await monitorGame();
          return;
        } catch (err) {
          console.error(`Failed to clear vote (attempt ${attempts + 1}/${maxRetries}):`, err);
          attempts++;

          if (attempts < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
          } else {
            throw err;
          }
        }
      }
    }

    function updateSubmitButton() {
      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      const errorMsg = document.getElementById("errorMessage");
      const charCount = document.getElementById("charCount");

      const word = input.value.trim();
      charCount.textContent = word.length;

      if (word.length === 0) {
        btn.disabled = true;
        errorMsg.classList.add("hidden");
        return;
      }

      if (!/^[\w√§√∂√º√Ñ√ñ√ú√ü]+$/.test(word)) {
        btn.disabled = true;
        errorMsg.innerText = "Bitte nur Buchstaben und Zahlen verwenden";
        errorMsg.classList.remove("hidden");
        return;
      }

      errorMsg.classList.add("hidden");
      btn.disabled = false;
      btn.onclick = () => submitWord(word);
    }

    document.getElementById("hint").addEventListener("input", updateSubmitButton);

    async function submitWord(word) {
      if (!word) return;

      const btn = document.getElementById("submitBtn");
      const originalText = btn.innerHTML;
      btn.innerHTML = "Wird gesendet... <span class='loading'></span>";
      btn.disabled = true;

      try {
        const res = await fetch(`/submit_word`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            player_id: playerId,
            word: word.trim()
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();

        // Check if impostor guessed the word
        if (data.status === "game_over" && data.winner === "impostor") {
          showGameNotification("GEWONNEN! Du hast das geheime Wort erraten!", "success");
        }

        document.getElementById("hint").value = "";
        document.getElementById("charCount").textContent = "0";
        await monitorGame();
      } catch (err) {
        console.error("Fehler beim Senden des Wortes:", err);
        const errorMsg = document.getElementById("errorMessage");
        errorMsg.innerText = `Fehler beim Senden: ${err.message}`;
        errorMsg.classList.remove("hidden");
      } finally {
        btn.innerHTML = originalText;
        updateSubmitButton();
      }
    }

    function setupSusButtons(players) {
      if (!players || !Array.isArray(players) || players.length === 0) {
        console.warn("[setupSusButtons] Keine Spieler gefunden");
        return;
      }

      const suspects = players.filter(p =>
        p.player_id !== playerId &&
        !p.eliminated &&
        !lastGameState?.eliminated_players?.includes(p.player_id)
      );

      const container = document.getElementById("susAction");
      container.innerHTML = "<label>üïµÔ∏è Verd√§chtigen:</label><br>";

      if (suspects.length === 0) {
        container.innerHTML += "<p>Keine weiteren Spieler verf√ºgbar!</p>";
        return;
      }

      suspects.forEach(p => {
        const btn = document.createElement("button");
        btn.textContent = `SUS ${p.name}`;
        btn.onclick = () => {
          if (!isVoting) startVote(p.player_id, p.name);
        };
        container.appendChild(btn);
      });
    }

    async function startVote(suspectId, suspectName) {
      if (isVoting) return;
      isVoting = true;

      const targetButton = event.target;
      const originalText = targetButton.textContent;

      targetButton.textContent = `SUS wird gestartet...`;
      targetButton.disabled = true;

      try {
        updateConnectionStatus("polling");
        const res = await fetch("/start_vote", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            initiator_id: playerId,
            suspect_id: suspectId
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();
        if (data.status === "vote_started") {
          currentSuspectId = suspectId;
          const initiatorName = data.initiator_name || playerName;
          const suspectName = data.suspect_name || "Unbekannt";

          console.log("Vote gestartet:", { initiatorName, suspectName });
          showSusOverlay(initiatorName, suspectName, false, false);
          updateConnectionStatus("connected");
        } else {
          throw new Error(data.error || "Unbekannter Fehler");
        }

        targetButton.textContent = originalText;
        targetButton.disabled = false;
      } catch (err) {
        console.error("Fehler beim Starten des Votes:", err);
        alert(`Fehler beim Starten des Votes: ${err.message}`);
        targetButton.textContent = originalText;
        targetButton.disabled = false;
        updateConnectionStatus("error");
      } finally {
        isVoting = false;
      }
    }

    function showSusOverlay(from, to, isPlayerSuspect, hasVoted) {
      console.log("[SUS] Overlay anzeigen:", from, "susst", to);

      document.getElementById("susText").innerText = `${from} SUSST ${to}`;
      document.getElementById("susOverlay").style.display = "flex";
      document.getElementById("voteResult").classList.add("hidden");
      document.getElementById("closeVote").classList.toggle("hidden", isPlayerSuspect);

      if (isPlayerSuspect) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du wirst verd√§chtigt! Warte auf die Abstimmung...";
      } else if (hasVoted) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du hast bereits abgestimmt!";
      } else {
        document.querySelector(".vote-btns").style.display = "flex";
        document.getElementById("voteUpBtn").disabled = false;
        document.getElementById("voteDownBtn").disabled = false;
      }

      // Show vote timer
      const timerElem = document.getElementById("voteTimer");
      timerElem.classList.remove("hidden");

      let secondsLeft = 15;
      const countdown = setInterval(() => {
        secondsLeft--;

        if (secondsLeft <= 0) {
          clearInterval(countdown);
          timerElem.innerHTML = "Abstimmung wird ausgewertet...";
        } else {
          timerElem.innerHTML = `Zeit zum Abstimmen: ${secondsLeft}s`;

          if (secondsLeft <= 5) {
            timerElem.style.color = "red";
            timerElem.style.fontWeight = "bold";
          }
        }
      }, 1000);

      window.voteTimer = countdown;

      document.getElementById("voteSummary").classList.remove("hidden");
      document.getElementById("voterList").innerHTML = "";
    }

    function hideSusOverlay() {
      document.getElementById("susOverlay").style.display = "none";
      document.getElementById("voteResult").classList.add("hidden");
      document.getElementById("voteSummary").classList.add("hidden");
      document.getElementById("voteTimer").classList.add("hidden");
      currentSuspectId = null;

      if (window.voteTimer) {
        clearInterval(window.voteTimer);
        window.voteTimer = null;
      }
    }

    document.getElementById("closeVote").addEventListener("click", hideSusOverlay);

    async function castVote(vote) {
      if (currentSuspectId === playerId) {
        alert("Du kannst nicht √ºber dich selbst abstimmen!");
        return;
      }

      const upBtn = document.getElementById("voteUpBtn");
      const downBtn = document.getElementById("voteDownBtn");
      upBtn.disabled = true;
      downBtn.disabled = true;

      const clickedBtn = vote === 'up' ? upBtn : downBtn;
      const originalHTML = clickedBtn.innerHTML;
      clickedBtn.innerHTML = `<span class='loading'></span>`;

      try {
        updateConnectionStatus("polling");
        const res = await fetch("/cast_vote", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            voter_id: playerId,
            vote
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();

        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");

        if (data.up_votes !== undefined && data.down_votes !== undefined) {
          let countElement = document.querySelector(".vote-count");
          if (!countElement) {
            countElement = document.createElement("div");
            countElement.classList.add("vote-count");
            document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
          }
          countElement.innerHTML = `Stand der Abstimmung: üëç ${data.up_votes} vs üëé ${data.down_votes}`;

          const votesCountElem = document.getElementById("votesCount");
          if (votesCountElem) {
            votesCountElem.textContent = `${data.total_votes}/${data.total_possible_votes}`;
          }
        }

        if (data.status === "vote_completed") {
          const resultText = getVoteResultText(data.result);
          document.getElementById("voteResult").innerHTML =
            `${resultText} (üëç ${data.up_votes} vs üëé ${data.down_votes})`;

          // Show notification for important results
          if (["impostor_eliminated", "impostor_wins", "player_eliminated"].includes(data.result)) {
            showVoteResultNotification(data.result);
          }
        } else {
          document.getElementById("voteResult").innerHTML = "Danke f√ºr dein Vote!";
        }

        await monitorGame();
        updateConnectionStatus("connected");
      } catch (err) {
        console.error("Fehler beim Abstimmen:", err);
        clickedBtn.innerHTML = originalHTML;
        upBtn.disabled = false;
        downBtn.disabled = false;
        alert(`Fehler beim Abstimmen: ${err.message}`);
        updateConnectionStatus("error");
      }
    }

    function showGameNotification(message, type = "success") {
      const notification = document.getElementById("gameNotification");
      const textElem = document.getElementById("notificationText");

      textElem.textContent = message;
      notification.className = `game-notification ${type}`;
      notification.classList.remove("hidden");

      // Auto-hide after 4 seconds
      setTimeout(() => {
        notification.classList.add("hidden");
      }, 4000);
    }

    function getVoteResultText(result) {
      switch (result) {
        case "impostor_eliminated": return "Der Impostor wurde entfernt! Spiel vorbei!";
        case "impostor_wins": return "Der Impostor hat gewonnen!";
        case "player_eliminated": return "Spieler wurde entfernt!";
        case "vote_failed": return "Spieler bleibt im Spiel!";
        default: return "Abstimmung abgeschlossen!";
      }
    }

    // Event-Listener f√ºr die Seite
    window.addEventListener("beforeunload", () => {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      if (votePollingInterval) clearInterval(votePollingInterval);
    });
  </script>
</body>
</html>