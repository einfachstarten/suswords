<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>SusWords – Spiel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Rubik&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
    :root {
      --bg: #1d1b3a;
      --panel: #2c294d;
      --highlight: #00f0ff;
      --accent: #ffcc00;
      --danger: #ff3260;
      --success: #4bdc65;
      --text: #ffffff;
      --muted: #888;
      --touch-target: 44px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: var(--bg);
      font-family: 'Rubik', sans-serif;
      color: var(--text);
      margin: 0;
      padding: 16px;
      min-height: 100vh;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    .logo {
      display: block;
      margin: 0 auto 20px;
      max-width: min(300px, 80vw);
      height: auto;
    }

    #playerNameBanner {
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      font-size: clamp(1.2rem, 4vw, 1.8rem);
      color: var(--highlight);
      margin-bottom: 20px;
      padding: 12px;
      background: var(--panel);
      border-radius: 12px;
      border: 2px solid var(--highlight);
    }

    section {
      background: var(--panel);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 12px rgba(0, 240, 255, 0.1);
    }

    input, button {
      width: 100%;
      padding: 14px 16px;
      margin-top: 12px;
      border: none;
      border-radius: 8px;
      font-size: 16px;
      min-height: var(--touch-target);
      transition: all 0.2s ease;
      font-family: inherit;
    }

    input {
      background: #1b1a2e;
      color: var(--text);
      border: 2px solid transparent;
    }

    input:focus {
      outline: none;
      border-color: var(--highlight);
      box-shadow: 0 0 0 3px rgba(0, 240, 255, 0.1);
    }

    button {
      background: var(--highlight);
      color: #000;
      font-weight: bold;
      cursor: pointer;
      border: 2px solid var(--highlight);
      text-transform: none;
      margin-bottom: 8px;
    }

    button:hover, button:focus {
      background: #00ccff;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 240, 255, 0.2);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      background: #555;
      color: #aaa;
      cursor: not-allowed;
      border-color: #555;
      transform: none;
      box-shadow: none;
    }

    #susAction {
      margin-top: 16px;
    }

    #susAction label {
      display: block;
      margin-bottom: 12px;
      color: var(--accent);
      font-weight: bold;
    }

    #susAction button {
      margin-bottom: 8px;
      background: var(--danger);
      border-color: var(--danger);
      color: white;
      font-size: 1rem;
      padding: 16px;
    }

    #susAction button:hover, #susAction button:focus {
      background: #ff1a4d;
      border-color: #ff1a4d;
    }

    /* Vote Overlay - Mobile Optimized */
    #susOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 9999;
      color: #fff;
      text-align: center;
      padding: 20px;
    }

    #susText {
      font-size: clamp(1.5rem, 6vw, 2.5rem);
      margin-bottom: 24px;
      font-family: 'Orbitron', sans-serif;
      color: var(--danger);
    }

    .vote-btns {
      display: flex;
      gap: 20px;
      margin: 20px 0;
      flex-wrap: wrap;
      justify-content: center;
    }

    .vote-btns button {
      font-size: clamp(1.5rem, 5vw, 2rem);
      padding: 20px;
      min-width: 120px;
      min-height: 80px;
      margin: 0;
      border-radius: 12px;
    }

    .vote-btns button:first-child {
      background: var(--success);
      border-color: var(--success);
    }

    .vote-btns button:last-child {
      background: var(--danger);
      border-color: var(--danger);
    }

    .hidden {
      display: none;
    }

    #closeVote {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--accent);
      color: #000;
      padding: 12px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      min-width: var(--touch-target);
      min-height: var(--touch-target);
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid var(--accent);
    }

    #errorMessage {
      color: #ff5555;
      margin-top: 10px;
      font-weight: bold;
      padding: 12px;
      background: rgba(255, 85, 85, 0.1);
      border-radius: 8px;
      border: 1px solid #ff5555;
    }

    .loading {
      position: relative;
      color: transparent !important;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 3px solid transparent;
      border-top: 3px solid currentColor;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .vote-result {
      font-size: clamp(1rem, 4vw, 1.5rem);
      margin: 20px 0;
      padding: 16px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 12px;
    }

    .word-counter {
      font-size: 0.9em;
      color: var(--muted);
      text-align: right;
      margin-top: 8px;
    }

    strike {
      color: var(--muted);
      text-decoration: line-through;
    }

    /* Game over screen styles */
    .game-over {
      text-align: center;
      padding: 30px;
      border-radius: 12px;
    }

    .game-over h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: clamp(1.5rem, 5vw, 2rem);
      margin-bottom: 20px;
    }

    .game-over p {
      font-size: clamp(1rem, 4vw, 1.2rem);
      margin-bottom: 15px;
      line-height: 1.4;
    }

    .success {
      box-shadow: 0 0 20px var(--success);
      border: 2px solid var(--success);
    }

    .danger {
      box-shadow: 0 0 20px var(--danger);
      border: 2px solid var(--danger);
    }

    .warning {
      box-shadow: 0 0 20px var(--accent);
      border: 2px solid var(--accent);
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      bottom: 20px;
      right: 20px;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.8em;
      background: rgba(0, 0, 0, 0.7);
      min-width: var(--touch-target);
      text-align: center;
      z-index: 1000;
    }

    .status-connected {
      color: var(--success);
      border: 1px solid var(--success);
    }

    .status-polling {
      color: var(--accent);
      border: 1px solid var(--accent);
    }

    .status-error {
      color: var(--danger);
      border: 1px solid var(--danger);
    }

    /* Vote status styles */
    .vote-count {
      margin: 16px 0;
      font-size: clamp(1rem, 4vw, 1.2rem);
      color: var(--accent);
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
    }

    .vote-timer {
      margin-top: 20px;
      font-size: clamp(1rem, 4vw, 1.2rem);
      color: var(--text);
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
    }

    .vote-summary {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 12px;
      padding: 16px;
      margin: 20px 0;
      max-width: 90vw;
    }

    .vote-summary h3 {
      margin-top: 0;
      color: var(--highlight);
      font-size: clamp(1rem, 4vw, 1.2rem);
    }

    .voter-list {
      list-style: none;
      padding: 0;
      margin: 12px 0;
      text-align: left;
    }

    .voter-list li {
      padding: 8px;
      border-bottom: 1px solid #444;
      font-size: clamp(0.9rem, 3vw, 1rem);
    }

    .voter-list .voted-up {
      color: var(--success);
    }

    .voter-list .voted-down {
      color: var(--danger);
    }

    .eliminated-player {
      color: var(--muted);
      text-decoration: line-through;
    }

    /* Custom Toast System */
    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--panel);
      color: var(--text);
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.7);
      border: 2px solid var(--highlight);
      z-index: 10000;
      min-width: 280px;
      max-width: 90vw;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      animation: toastSlideIn 0.3s ease-out;
    }

    .toast.success {
      border-color: var(--success);
    }

    .toast.danger {
      border-color: var(--danger);
    }

    .toast.warning {
      border-color: var(--accent);
    }

    .toast .toast-icon {
      font-size: 2.5em;
      margin-bottom: 12px;
    }

    .toast .toast-message {
      font-size: clamp(1rem, 4vw, 1.2rem);
      margin-bottom: 16px;
      line-height: 1.3;
    }

    .toast .toast-close {
      background: var(--highlight);
      color: #000;
      border: none;
      padding: 12px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      min-height: var(--touch-target);
      width: auto;
      margin: 0;
    }

    @keyframes toastSlideIn {
      from {
        opacity: 0;
        transform: translate(-50%, -60%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }

    /* History list improvements */
    #historyList {
      padding: 0;
      margin: 16px 0;
    }

    #historyList li {
      padding: 12px;
      margin-bottom: 8px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      border-left: 4px solid var(--highlight);
      font-size: clamp(0.9rem, 3vw, 1rem);
    }

    /* Countdown styles */
    #redirectCountdown {
      font-size: clamp(0.9rem, 3vw, 1rem);
      color: var(--accent);
      margin-top: 20px;
      font-family: 'Orbitron', sans-serif;
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 8px;
    }

    #countdown {
      font-weight: bold;
      color: var(--highlight);
      font-size: 1.2em;
    }

    /* Responsive improvements */
    @media (max-width: 480px) {
      body {
        padding: 12px;
      }

      section {
        padding: 16px;
        margin-bottom: 16px;
      }

      .vote-btns {
        gap: 16px;
      }

      .vote-btns button {
        min-width: 100px;
        min-height: 70px;
        font-size: 1.5rem;
      }

      .vote-summary {
        padding: 12px;
        margin: 16px 0;
      }

      .connection-status {
        bottom: 16px;
        right: 16px;
      }
    }

    /* Improved focus visibility */
    button:focus-visible, input:focus-visible {
      outline: 3px solid var(--accent);
      outline-offset: 2px;
    }

    /* Better touch targets */
    @media (pointer: coarse) {
      button {
        min-height: 48px;
        padding: 16px;
      }

      input {
        min-height: 48px;
        padding: 16px;
      }

      #closeVote {
        min-width: 48px;
        min-height: 48px;
        padding: 16px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <img src="/static/suswords.png" alt="SusWords Logo" class="logo">
    <div id="playerNameBanner">Spieler: ...</div>

    <section id="gameSection">
      <div id="turnInfo">🎯 <b>Aktueller Spieler:</b> –</div>
      <div id="status">📝 Geheimes Wort: –</div>

      <div id="wordSection" class="hidden">
        <label for="hint">Dein Hinweiswort:</label>
        <input id="hint" placeholder="Dein Hinweiswort" maxlength="30">
        <div class="word-counter"><span id="charCount">0</span>/30</div>
        <div id="errorMessage" class="hidden"></div>
        <button id="submitBtn" disabled>📝 Abschicken</button>
        <div id="susAction"></div>
      </div>

      <div>
        <b>📜 History:</b>
        <ul id="historyList"></ul>
      </div>
    </section>
  </div>

  <div id="susOverlay">
    <div id="closeVote">✕</div>
    <div id="susText">...</div>
    <div class="vote-btns">
      <button id="voteUpBtn" onclick="castVote('up')">👍</button>
      <button id="voteDownBtn" onclick="castVote('down')">👎</button>
    </div>
    <div id="voteTimer" class="vote-timer hidden">Zeit zum Abstimmen: 15s</div>
    <div id="voteSummary" class="vote-summary hidden">
      <h3>Abstimmung (<span id="votesCount">0/0</span> abgestimmt):</h3>
      <ul id="voterList" class="voter-list"></ul>
    </div>
    <div id="voteResult" class="vote-result hidden"></div>
  </div>

  <div id="connectionStatus" class="connection-status status-connected">
    Verbunden
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get("game_id");
    const playerId = urlParams.get("player_id");

    let playerName = "";
    let isImpostor = false;
    let isPolling = false;
    let isVoting = false;
    let gamePollingInterval = null;
    let votePollingInterval = null;
    let lastGameState = null;
    let currentSuspectId = null;
    let connectionStatus = "connected";
    let retryAttempts = 0;
    let maxRetryAttempts = 5;

    // Custom Toast System
    function showToast(message, type = 'success', icon = '✅') {
      const existingToasts = document.querySelectorAll('.toast');
      existingToasts.forEach(toast => toast.remove());

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <div class="toast-icon">${icon}</div>
        <div class="toast-message">${message}</div>
        <button class="toast-close" onclick="this.parentElement.remove()">OK</button>
      `;

      document.body.appendChild(toast);

      setTimeout(() => {
        if (toast.parentElement) {
          toast.remove();
        }
      }, 4000);
    }

    function setButtonLoading(button, loading = true) {
      if (loading) {
        button.dataset.originalText = button.textContent;
        button.textContent = 'Wird geladen...';
        button.classList.add('loading');
        button.disabled = true;
      } else {
        button.textContent = button.dataset.originalText || button.textContent;
        button.classList.remove('loading');
        button.disabled = false;
      }
    }

    if (!gameId || !playerId) {
      document.getElementById("gameSection").innerHTML =
        "<div id='errorMessage'>Fehler: Game ID oder Player ID fehlt in der URL.</div>";
    } else {
      initGame();
    }

    async function initGame() {
      try {
        await lookupOwnPlayerName();
        await monitorGame();
        startGamePolling();
      } catch (err) {
        console.error("Fehler beim Initialisieren des Spiels:", err);
        document.getElementById("gameSection").innerHTML =
          `<div id='errorMessage'>Fehler beim Starten des Spiels: ${err.message}</div>`;
        updateConnectionStatus("error");
      }
    }

    function startGamePolling() {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      gamePollingInterval = setInterval(monitorGame, 3000);
    }

    function updateConnectionStatus(status) {
      const statusElem = document.getElementById("connectionStatus");
      connectionStatus = status;

      statusElem.className = "connection-status";
      switch (status) {
        case "connected":
          statusElem.classList.add("status-connected");
          statusElem.innerText = "Verbunden";
          break;
        case "polling":
          statusElem.classList.add("status-polling");
          statusElem.innerText = "Aktualisiere...";
          break;
        case "error":
          statusElem.classList.add("status-error");
          statusElem.innerText = "Verbindungsfehler";
          break;
      }
    }

    async function lookupOwnPlayerName() {
      try {
        updateConnectionStatus("polling");
        const res = await fetch(`/players_in_game/${gameId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();
        const player = data.players.find(p => p.player_id === playerId);

        if (!player) {
          throw new Error("Spieler nicht im Spiel gefunden");
        }

        playerName = player.name;
        document.getElementById("playerNameBanner").innerText = `🎮 Spieler: ${playerName}`;
        updateConnectionStatus("connected");
        retryAttempts = 0;
        return data;
      } catch (err) {
        console.error("Fehler beim Abrufen des Spielernamens:", err);
        document.getElementById("playerNameBanner").innerHTML =
          `Spieler: <span style="color: #ff5555">Verbindungsfehler</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts <= maxRetryAttempts) {
          console.log(`Versuch ${retryAttempts}/${maxRetryAttempts}: Wiederverbinden in 5 Sekunden...`);
          setTimeout(lookupOwnPlayerName, 5000);
        }

        throw err;
      }
    }

    async function monitorGame() {
      if (isPolling) return;
      isPolling = true;
      updateConnectionStatus("polling");

      try {
        const res = await fetch(`/game_state/${gameId}/${playerId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();

        if (data.game_status === "finished") {
          showGameOverScreen(data);
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        if (data.status === "eliminated") {
          document.getElementById("gameSection").innerHTML =
            `<div id='errorMessage'>${data.message || "Du wurdest aus dem Spiel entfernt!"}</div>`;
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        if (!data || data.error) {
          throw new Error(data?.error || "Unbekannter Serverfehler");
        }

        lastGameState = data;

        try {
          const playersRes = await fetch(`/players_in_game/${gameId}`);
          if (!playersRes.ok) throw new Error(`Fehler beim Laden der Spielerliste: ${playersRes.status}`);
          const playersData = await playersRes.json();

          updateGameUI(data, playersData);

          if (data.active_vote) {
            handleActiveVote(data);
          } else {
            if (votePollingInterval) {
              clearInterval(votePollingInterval);
              votePollingInterval = null;
            }

            if (document.getElementById("susOverlay").style.display === "flex") {
              hideSusOverlay();
            }
          }

          updateConnectionStatus("connected");
          retryAttempts = 0;
        } catch (playersErr) {
          console.error("Fehler beim Laden der Spielerliste:", playersErr);
          updateGameUI(data, { players: [] });
          updateConnectionStatus("error");
        }
      } catch (err) {
        console.error("Fehler beim Aktualisieren des Spielstatus:", err);
        document.getElementById("status").innerHTML =
          `<span style="color: #ff5555">Verbindungsfehler: ${err.message}</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts > maxRetryAttempts) {
          console.log(`Zu viele fehlgeschlagene Versuche. Polling wird reduziert.`);
          if (gamePollingInterval) {
            clearInterval(gamePollingInterval);
            gamePollingInterval = setInterval(monitorGame, 10000);
          }
        }
      } finally {
        isPolling = false;
      }
    }

    function handleActiveVote(data) {
      if (data.active_vote.overlay_hidden) {
        hideSusOverlay();
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim Löschen des Votings:", err);
          }
        }, 500);
        return;
      }

      const hasVotes = Object.keys(data.active_vote.votes || {}).length > 0;
      const hasResult = !!data.active_vote.result;

      if (!hasVotes && !hasResult) {
        return;
      }

      const isPlayerSuspect = data.active_vote.suspect_id === playerId;
      currentSuspectId = data.active_vote.suspect_id;
      const initiatorName = data.active_vote.initiator_name || "Unbekannt";
      const suspectName = data.active_vote.suspect_name || "Unbekannt";

      if (document.getElementById("susOverlay").style.display !== "flex") {
        const hasVoted = data.active_vote.votes && data.active_vote.votes[playerId];
        showSusOverlay(initiatorName, suspectName, isPlayerSuspect, hasVoted);
      }

      if (!votePollingInterval) {
        votePollingInterval = setInterval(async () => {
          try {
            const voteRes = await fetch(`/vote_status/${gameId}/${playerId}`);
            if (!voteRes.ok) throw new Error(`Vote status error: ${voteRes.status}`);

            const voteData = await voteRes.json();
            if (voteData.active) {
              updateVoteDisplay(voteData);
            } else if (document.getElementById("susOverlay").style.display === "flex") {
              hideSusOverlay();
            }
          } catch (err) {
            console.error("Fehler beim Vote-Status:", err);
          }
        }, 1000);
      }
    }

    function updateVoteDisplay(voteData) {
      if (!voteData || !voteData.active) return;

      const upVotes = voteData.votes.up || 0;
      const downVotes = voteData.votes.down || 0;

      let countElement = document.querySelector(".vote-count");
      if (!countElement) {
        countElement = document.createElement("div");
        countElement.classList.add("vote-count");
        document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
      }
      countElement.innerHTML = `Stand der Abstimmung: 👍 ${upVotes} vs 👎 ${downVotes}`;

      const votesCountElem = document.getElementById("votesCount");
      if (votesCountElem) {
        votesCountElem.textContent = `${voteData.votes_cast}/${voteData.votes_needed}`;
      }

      const voterList = document.getElementById("voterList");
      if (voterList) {
        voterList.innerHTML = "";
        const voters = voteData.voters || {};

        document.getElementById("voteSummary").classList.remove("hidden");

        Object.entries(voters).forEach(([voterId, voterInfo]) => {
          const li = document.createElement("li");
          const voteEmoji = voterInfo.vote === "up" ? "👍" : "👎";
          li.textContent = `${voterInfo.name}: ${voteEmoji}`;
          li.classList.add(voterInfo.vote === "up" ? "voted-up" : "voted-down");
          voterList.appendChild(li);
        });
      }

      if (voteData.result) {
        document.getElementById("voteResult").classList.remove("hidden");
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteTimer").classList.add("hidden");

        const resultText = getVoteResultText(voteData.result);
        document.getElementById("voteResult").innerHTML =
          `${resultText} (👍 ${upVotes} vs 👎 ${downVotes})`;

        if (["impostor_eliminated", "impostor_wins", "player_eliminated"].includes(voteData.result)) {
          showVoteResultNotification(voteData.result);
        }
      }

      if (voteData.overlay_hidden) {
        hideSusOverlay();
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim Löschen des Votings:", err);
          }
        }, 500);
      }
    }

    function showVoteResultNotification(result) {
      let message = "";
      let type = "success";

      switch (result) {
    function showVoteResultNotification(result) {
      let message = "";
      let type = "success";

      switch (result) {
        case "impostor_eliminated":
          if (isImpostor) {
            message = "VERLOREN! Du wurdest als Impostor entlarvt!";
            type = "danger";
          } else {
            message = "GEWONNEN! Ihr habt den Impostor gefunden!";
            type = "success";
          }
          break;
        case "impostor_wins":
          if (isImpostor) {
            message = "GEWONNEN! Du hast als Impostor überlebt!";
            type = "success";
          } else {
            message = "VERLOREN! Der Impostor hat überlebt!";
            type = "danger";
          }
          break;
        case "player_eliminated":
          if (isImpostor) {
            message = "ERFOLG! Ein unschuldiger Spieler wurde entfernt!";
            type = "success";
          } else {
            message = "OH NEIN! Ein unschuldiger Spieler wurde entfernt!";
            type = "warning";
          }
          break;
      }

      if (message) {
        showToast(message, type, type === 'success' ? '🏆' : type === 'danger' ? '💀' : '⚠️');
      }
    }

    function showGameOverScreen(data) {
      const isImpostor = data.your_role === "impostor";
      const impostorWon = data.winner === "impostor";
      const secretWord = data.word || data.your_word || "???";

      let message = "";
      let emoji = "";
      let colorClass = "";

      if (isImpostor) {
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Du hast das Wort erraten und gewonnen!";
            showToast("GEWONNEN! Du hast das geheime Wort erraten!", "success", "🏆");
          } else {
            message = "Du hast gewonnen! Die Spieler konnten dich nicht finden.";
            showToast("GEWONNEN! Du hast alle anderen überlebt!", "success", "🏆");
          }
          emoji = "🏆";
          colorClass = "success";
        } else {
          message = "Game Over! Du wurdest entlarvt.";
          showToast("VERLOREN! Du wurdest als Impostor entlarvt!", "danger", "💀");
          emoji = "🚫";
          colorClass = "danger";
        }
      } else {
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Game Over! Der Impostor hat das Wort erraten.";
            showToast("VERLOREN! Der Impostor hat das Wort erraten!", "danger", "💀");
          } else {
            message = "Game Over! Der Impostor hat gewonnen.";
            showToast("VERLOREN! Der Impostor hat überlebt!", "danger", "💀");
          }
          emoji = "💀";
          colorClass = "danger";
        } else {
          message = "Gratulation! Ihr habt den Impostor gefunden und das Spiel gewonnen!";
          showToast("GEWONNEN! Der Impostor wurde enttarnt!", "success", "🏆");
          emoji = "🏆";
          colorClass = "success";
        }
      }

      document.getElementById("gameSection").innerHTML = `
        <div class="game-over ${colorClass}">
          <h2>${emoji} Spiel beendet ${emoji}</h2>
          <p>${message}</p>
          <p>Das geheime Wort war: <strong>${secretWord}</strong></p>
          <p id="redirectCountdown">Weiterleitung zur Ergebnisseite in <span id="countdown">5</span> Sekunden...</p>
        </div>
      `;

      let countdown = 5;
      const countdownInterval = setInterval(() => {
        countdown--;
        const countdownElem = document.getElementById("countdown");
        if (countdownElem) {
          countdownElem.textContent = countdown;
        }

        if (countdown <= 0) {
          clearInterval(countdownInterval);
          redirectToGameEnded(data);
        }
      }, 1000);
    }

    function redirectToGameEnded(gameData) {
      const params = new URLSearchParams({
        game_id: gameId,
        player_id: playerId,
        result: gameData.end_reason || "game_ended",
        winner: gameData.winner || "unknown",
        word: gameData.word || gameData.your_word || "???",
        is_impostor: (gameData.your_role === "impostor").toString()
      });

      window.location.href = `/game_ended?${params.toString()}`;
    }

    function updateGameUI(data, playersData) {
      const currentPlayer = data.current_player;
      const isMyTurn = currentPlayer === data.player_name;
      isImpostor = data.your_role === "impostor";

      document.getElementById("turnInfo").innerHTML =
        `🎯 <b>Aktueller Spieler:</b> ${currentPlayer || '-'}`;

      document.getElementById("status").innerHTML = isImpostor
        ? "🕵️ Du bist der Impostor! Versuche das Wort zu erraten."
        : `🔤 <b>Geheimes Wort:</b> ${data.your_word || '-'}`;

      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      document.getElementById("wordSection").classList.toggle("hidden", !isMyTurn);

      const playerMap = {};
      if (playersData && playersData.players) {
        playersData.players.forEach(p => playerMap[p.player_id] = p.name);
      }

      if (isMyTurn) {
        input.disabled = false;
        input.focus();
        updateSubmitButton();
        setupSusButtons(playersData.players || []);
      } else {
        input.disabled = true;
        btn.disabled = true;
        document.getElementById("susAction").innerHTML = "";
      }

      const historyContainer = document.getElementById("historyList");
      historyContainer.innerHTML = "";

      const eliminatedPlayers = data.eliminated_players || [];

      data.history.forEach(entry => {
        const li = document.createElement("li");
        const playerName = playerMap[entry.player_id] || entry.player_id;
        const isEliminated = eliminatedPlayers.includes(entry.player_id) ||
            playersData?.players?.find(p => p.player_id === entry.player_id)?.eliminated;

        if (isEliminated) {
          li.innerHTML = `<strike>${playerName}: ${entry.word}</strike>`;
          li.classList.add("eliminated-player");
        } else {
          li.textContent = `${playerName}: ${entry.word}`;
        }

        historyContainer.appendChild(li);
      });
    }

    async function clearVoteWithRetry(maxRetries = 3) {
      let attempts = 0;

      while (attempts < maxRetries) {
        try {
          const res = await fetch("/clear_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_id: gameId })
          });

          if (!res.ok) throw new Error(`Server error: ${res.status}`);

          console.log("Vote successfully cleared");
          await monitorGame();
          return;
        } catch (err) {
          console.error(`Failed to clear vote (attempt ${attempts + 1}/${maxRetries}):`, err);
          attempts++;

          if (attempts < maxRetries) {
            await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
          } else {
            throw err;
          }
        }
      }
    }

    function updateSubmitButton() {
      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      const errorMsg = document.getElementById("errorMessage");
      const charCount = document.getElementById("charCount");

      const word = input.value.trim();
      charCount.textContent = word.length;

      if (word.length === 0) {
        btn.disabled = true;
        errorMsg.classList.add("hidden");
        return;
      }

      if (!/^[\wäöüÄÖÜß]+$/.test(word)) {
        btn.disabled = true;
        errorMsg.innerText = "Bitte nur Buchstaben und Zahlen verwenden";
        errorMsg.classList.remove("hidden");
        return;
      }

      errorMsg.classList.add("hidden");
      btn.disabled = false;
      btn.onclick = () => submitWord(word);
    }

    document.getElementById("hint").addEventListener("input", updateSubmitButton);

    async function submitWord(word) {
      if (!word) return;

      const btn = document.getElementById("submitBtn");
      setButtonLoading(btn, true);

      try {
        const res = await fetch(`/submit_word`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            player_id: playerId,
            word: word.trim()
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();

        if (data.status === "game_over" && data.winner === "impostor") {
          showToast("GEWONNEN! Du hast das geheime Wort erraten!", "success", "🏆");
        }

        document.getElementById("hint").value = "";
        document.getElementById("charCount").textContent = "0";
        await monitorGame();
      } catch (err) {
        console.error("Fehler beim Senden des Wortes:", err);
        showToast(`Fehler beim Senden: ${err.message}`, "danger", "❌");
      } finally {
        setButtonLoading(btn, false);
      }
    }

    function setupSusButtons(players) {
      if (!players || !Array.isArray(players) || players.length === 0) {
        console.warn("[setupSusButtons] Keine Spieler gefunden");
        return;
      }

      const suspects = players.filter(p =>
        p.player_id !== playerId &&
        !p.eliminated &&
        !lastGameState?.eliminated_players?.includes(p.player_id)
      );

      const container = document.getElementById("susAction");
      container.innerHTML = "<label>🕵️ Verdächtigen:</label>";

      if (suspects.length === 0) {
        container.innerHTML += "<p>Keine weiteren Spieler verfügbar!</p>";
        return;
      }

      suspects.forEach(p => {
        const btn = document.createElement("button");
        btn.textContent = `SUS ${p.name}`;
        btn.onclick = () => {
          if (!isVoting) startVote(p.player_id, p.name);
        };
        container.appendChild(btn);
      });
    }

    async function startVote(suspectId, suspectName) {
      if (isVoting) return;
      isVoting = true;

      const targetButton = event.target;
      setButtonLoading(targetButton, true);

      try {
        updateConnectionStatus("polling");
        const res = await fetch("/start_vote", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            initiator_id: playerId,
            suspect_id: suspectId
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();
        if (data.status === "vote_started") {
          currentSuspectId = suspectId;
          const initiatorName = data.initiator_name || playerName;
          const suspectName = data.suspect_name || "Unbekannt";

          console.log("Vote gestartet:", { initiatorName, suspectName });
          showSusOverlay(initiatorName, suspectName, false, false);
          updateConnectionStatus("connected");
        } else {
          throw new Error(data.error || "Unbekannter Fehler");
        }
      } catch (err) {
        console.error("Fehler beim Starten des Votes:", err);
        showToast(`Fehler beim Starten des Votes: ${err.message}`, "danger", "❌");
        updateConnectionStatus("error");
      } finally {
        setButtonLoading(targetButton, false);
        isVoting = false;
      }
    }

    function showSusOverlay(from, to, isPlayerSuspect, hasVoted) {
      console.log("[SUS] Overlay anzeigen:", from, "susst", to);

      document.getElementById("susText").innerText = `${from} SUSST ${to}`;
      document.getElementById("susOverlay").style.display = "flex";
      document.getElementById("voteResult").classList.add("hidden");
      document.getElementById("closeVote").classList.toggle("hidden", isPlayerSuspect);

      if (isPlayerSuspect) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du wirst verdächtigt! Warte auf die Abstimmung...";
      } else if (hasVoted) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du hast bereits abgestimmt!";
      } else {
        document.querySelector(".vote-btns").style.display = "flex";
        document.getElementById("voteUpBtn").disabled = false;
        document.getElementById("voteDownBtn").disabled = false;
      }

      const timerElem = document.getElementById("voteTimer");
      timerElem.classList.remove("hidden");

      let secondsLeft = 15;
      const countdown = setInterval(() => {
        secondsLeft--;

        if (secondsLeft <= 0) {
          clearInterval(countdown);
          timerElem.innerHTML = "Abstimmung wird ausgewertet...";
        } else {
          timerElem.innerHTML = `Zeit zum Abstimmen: ${secondsLeft}s`;

          if (secondsLeft <= 5) {
            timerElem.style.color = "red";
            timerElem.style.fontWeight = "bold";
          }
        }
      }, 1000);

      window.voteTimer = countdown;

      document.getElementById("voteSummary").classList.remove("hidden");
      document.getElementById("voterList").innerHTML = "";
    }

    function hideSusOverlay() {
      document.getElementById("susOverlay").style.display = "none";
      document.getElementById("voteResult").classList.add("hidden");
      document.getElementById("voteSummary").classList.add("hidden");
      document.getElementById("voteTimer").classList.add("hidden");
      currentSuspectId = null;

      if (window.voteTimer) {
        clearInterval(window.voteTimer);
        window.voteTimer = null;
      }
    }

    document.getElementById("closeVote").addEventListener("click", hideSusOverlay);

    async function castVote(vote) {
      if (currentSuspectId === playerId) {
        showToast("Du kannst nicht über dich selbst abstimmen!", "warning", "⚠️");
        return;
      }

      const upBtn = document.getElementById("voteUpBtn");
      const downBtn = document.getElementById("voteDownBtn");
      const clickedBtn = vote === 'up' ? upBtn : downBtn;

      setButtonLoading(upBtn, true);
      setButtonLoading(downBtn, true);

      try {
        updateConnectionStatus("polling");
        const res = await fetch("/cast_vote", {
          method: "POST",
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            voter_id: playerId,
            vote
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        const data = await res.json();

        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");

        if (data.up_votes !== undefined && data.down_votes !== undefined) {
          let countElement = document.querySelector(".vote-count");
          if (!countElement) {
            countElement = document.createElement("div");
            countElement.classList.add("vote-count");
            document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
          }
          countElement.innerHTML = `Stand der Abstimmung: 👍 ${data.up_votes} vs 👎 ${data.down_votes}`;

          const votesCountElem = document.getElementById("votesCount");
          if (votesCountElem) {
            votesCountElem.textContent = `${data.total_votes}/${data.total_possible_votes}`;
          }
        }

        if (data.status === "vote_completed") {
          const resultText = getVoteResultText(data.result);
          document.getElementById("voteResult").innerHTML =
            `${resultText} (👍 ${data.up_votes} vs 👎 ${data.down_votes})`;

          if (["impostor_eliminated", "impostor_wins", "player_eliminated"].includes(data.result)) {
            showVoteResultNotification(data.result);
          }
        } else {
          document.getElementById("voteResult").innerHTML = "Danke für dein Vote!";
        }

        await monitorGame();
        updateConnectionStatus("connected");
      } catch (err) {
        console.error("Fehler beim Abstimmen:", err);
        showToast(`Fehler beim Abstimmen: ${err.message}`, "danger", "❌");
        updateConnectionStatus("error");
        setButtonLoading(upBtn, false);
        setButtonLoading(downBtn, false);
      }
    }

    function getVoteResultText(result) {
      switch (result) {
        case "impostor_eliminated": return "Der Impostor wurde entfernt! Spiel vorbei!";
        case "impostor_wins": return "Der Impostor hat gewonnen!";
        case "player_eliminated": return "Spieler wurde entfernt!";
        case "vote_failed": return "Spieler bleibt im Spiel!";
        default: return "Abstimmung abgeschlossen!";
      }
    }

    window.addEventListener("beforeunload", () => {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      if (votePollingInterval) clearInterval(votePollingInterval);
    });
  </script>
</body>
</html>