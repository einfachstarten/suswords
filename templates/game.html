<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>SusWords ‚Äì Spiel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&family=Rubik&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
  <style>
    :root {
      --bg: #1d1b3a;
      --panel: #2c294d;
      --highlight: #00f0ff;
      --accent: #ffcc00;
      --danger: #ff3260;
      --success: #4bdc65;
      --text: #ffffff;
      --muted: #888;
    }

    body {
      background: var(--bg);
      font-family: 'Rubik', sans-serif;
      color: var(--text);
      margin: 0;
      padding: 20px;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    .logo {
      display: block;
      margin: 0 auto 20px;
      max-width: 300px;
    }

    #playerNameBanner {
      font-family: 'Orbitron', sans-serif;
      text-align: center;
      font-size: 1.8em;
      color: var(--highlight);
      margin-bottom: 20px;
    }

    section {
      background: var(--panel);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 0 10px var(--highlight);
    }

    input, button {
      width: 100%;
      padding: 10px;
      margin-top: 10px;
      border: none;
      border-radius: 5px;
      font-size: 1em;
    }

    input {
      background: #1b1a2e;
      color: var(--text);
    }

    button {
      background: var(--highlight);
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }

    button:disabled {
      background: #555;
      color: #aaa;
      cursor: not-allowed;
    }

    #susAction {
      margin-top: 15px;
    }

    #susAction button {
      margin-bottom: 5px;
    }

    #susOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 9999;
      color: #fff;
      text-align: center;
    }

    #susText {
      font-size: 2.5em;
      margin-bottom: 20px;
      font-family: 'Orbitron', sans-serif;
      color: var(--danger);
    }

    .vote-btns button {
      font-size: 2em;
      padding: 20px;
      width: 120px;
      margin: 10px;
    }

    .vote-btns button:first-child {
      background: var(--success);
    }

    .vote-btns button:last-child {
      background: var(--danger);
    }

    .hidden {
      display: none;
    }

    #closeVote {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--accent);
      color: #000;
      padding: 5px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    #errorMessage {
      color: #ff5555;
      margin-top: 10px;
      font-weight: bold;
    }

    .loading {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(255,255,255,.3);
      border-radius: 50%;
      border-top-color: #fff;
      animation: spin 1s ease-in-out infinite;
      margin-left: 10px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .vote-result {
      font-size: 1.5em;
      margin: 20px 0;
    }

    .word-counter {
      font-size: 0.8em;
      color: var(--muted);
      text-align: right;
      margin-top: 5px;
    }

    strike {
      color: var(--muted);
      text-decoration: line-through;
    }

    /* Game over screen styles */
    .game-over {
      text-align: center;
      padding: 30px;
      border-radius: 10px;
    }

    .game-over h2 {
      font-family: 'Orbitron', sans-serif;
      font-size: 2em;
      margin-bottom: 20px;
    }

    .game-over p {
      font-size: 1.2em;
      margin-bottom: 15px;
    }

    .game-over button {
      background: var(--accent);
      margin-top: 20px;
      padding: 15px;
      font-size: 1.2em;
      max-width: 200px;
    }

    .success {
      box-shadow: 0 0 20px var(--success);
    }

    .danger {
      box-shadow: 0 0 20px var(--danger);
    }

    .warning {
      box-shadow: 0 0 20px var(--accent);
    }

    /* Game outcome animation */
    .outcome-animation {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0,0,0,0.85);
      z-index: 9999;
      animation: fadeOutAnimation 4s forwards;
      animation-delay: 3s;
    }

    .outcome-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 3em;
      text-align: center;
      margin-bottom: 40px;
      animation: pulseAnimation 2s infinite;
    }

    .outcome-win {
      color: var(--success);
      text-shadow: 0 0 10px var(--success);
    }

    .outcome-lose {
      color: var(--danger);
      text-shadow: 0 0 10px var(--danger);
    }

    .outcome-neutral {
      color: var(--accent);
      text-shadow: 0 0 10px var(--accent);
    }

    @keyframes pulseAnimation {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.1); opacity: 0.9; }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes fadeOutAnimation {
      0% { opacity: 1; }
      100% { opacity: 0; visibility: hidden; }
    }

    /* New styles for enhanced voting UI */
    .vote-count {
      margin: 10px 0;
      font-size: 1.2em;
      color: var(--accent);
    }

    .vote-timer {
      margin-top: 20px;
      font-size: 1.2em;
      color: var(--text);
    }

    .vote-summary {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 10px;
      padding: 10px;
      margin: 15px 0;
    }

    .vote-summary h3 {
      margin-top: 0;
      color: var(--highlight);
    }

    .voter-list {
      list-style: none;
      padding: 0;
      margin: 10px 0;
      text-align: left;
    }

    .voter-list li {
      padding: 5px;
      border-bottom: 1px solid #444;
    }

    .voter-list .voted-up {
      color: var(--success);
    }

    .voter-list .voted-down {
      color: var(--danger);
    }

    .voter-list .not-voted {
      color: var(--muted);
    }

    .eliminated-player {
      color: var(--muted);
      text-decoration: line-through;
    }

    .connection-status {
      position: fixed;
      bottom: 10px;
      right: 10px;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      background: rgba(0, 0, 0, 0.5);
    }

    .status-connected {
      color: var(--success);
    }

    .status-polling {
      color: var(--accent);
    }

    .status-error {
      color: var(--danger);
    }
  </style>
</head>
<body>
  <div class="container">
    <img src="/static/suswords.png" alt="SusWords Logo" class="logo">
    <div id="playerNameBanner">Spieler: ...</div>

    <section id="gameSection">
      <div id="turnInfo">üéØ <b>Aktueller Spieler:</b> ‚Äì</div>
      <div id="status">üìù Geheimes Wort: ‚Äì</div>

      <div id="wordSection" class="hidden">
        <label for="hint">Dein Hinweiswort:</label>
        <input id="hint" placeholder="Dein Hinweiswort" maxlength="30">
        <div class="word-counter"><span id="charCount">0</span>/30</div>
        <div id="errorMessage" class="hidden"></div>
        <button id="submitBtn" disabled>üìù Abschicken</button>
        <div id="susAction"></div>
      </div>

      <div>
        <b>üìú History:</b>
        <ul id="historyList"></ul>
      </div>
    </section>
  </div>

  <div id="susOverlay">
    <div id="closeVote">X</div>
    <div id="susText">...</div>
    <div class="vote-btns">
      <button id="voteUpBtn" onclick="castVote('up')">üëç</button>
      <button id="voteDownBtn" onclick="castVote('down')">üëé</button>
    </div>
    <div id="voteTimer" class="vote-timer hidden">Zeit zum Abstimmen: 15s</div>
    <div id="voteSummary" class="vote-summary hidden">
      <h3>Abstimmung (<span id="votesCount">0/0</span> abgestimmt):</h3>
      <ul id="voterList" class="voter-list"></ul>
    </div>
    <div id="voteResult" class="vote-result hidden"></div>
  </div>

  <div id="outcomeAnimation" class="outcome-animation hidden">
    <div id="outcomeText" class="outcome-text">Du hast gewonnen!</div>
    <div id="outcomeDescription"></div>
  </div>

  <div id="connectionStatus" class="connection-status status-connected">
    Verbunden
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const gameId = urlParams.get("game_id");
    const playerId = urlParams.get("player_id");

    let playerName = "";
    let isImpostor = false;
    let isPolling = false;
    let isVoting = false;
    let gamePollingInterval = null;
    let votePollingInterval = null;
    let lastGameState = null;
    let currentSuspectId = null;
    let connectionStatus = "connected";
    let retryAttempts = 0;
    let maxRetryAttempts = 5;

    // Pr√ºfen, ob Game ID und Player ID vorhanden sind
    if (!gameId || !playerId) {
      document.getElementById("gameSection").innerHTML =
        "<div id='errorMessage'>Fehler: Game ID oder Player ID fehlt in der URL.</div>";
    } else {
      initGame();
    }

    async function initGame() {
      try {
        await lookupOwnPlayerName();
        await monitorGame();
        startGamePolling();
      } catch (err) {
        console.error("Fehler beim Initialisieren des Spiels:", err);
        document.getElementById("gameSection").innerHTML =
          `<div id='errorMessage'>Fehler beim Starten des Spiels: ${err.message}</div>`;
        updateConnectionStatus("error");
      }
    }

    function startGamePolling() {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      gamePollingInterval = setInterval(monitorGame, 3000);
    }

    // New function to handle connection status display
    function updateConnectionStatus(status) {
      const statusElem = document.getElementById("connectionStatus");
      connectionStatus = status;

      statusElem.className = "connection-status";
      switch (status) {
        case "connected":
          statusElem.classList.add("status-connected");
          statusElem.innerText = "Verbunden";
          break;
        case "polling":
          statusElem.classList.add("status-polling");
          statusElem.innerText = "Aktualisiere...";
          break;
        case "error":
          statusElem.classList.add("status-error");
          statusElem.innerText = "Verbindungsfehler";
          break;
      }
    }

    async function lookupOwnPlayerName() {
      try {
        updateConnectionStatus("polling");
        const res = await fetch(`/players_in_game/${gameId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();
        const player = data.players.find(p => p.player_id === playerId);

        if (!player) {
          throw new Error("Spieler nicht im Spiel gefunden");
        }

        playerName = player.name;
        document.getElementById("playerNameBanner").innerText = `üéÆ Spieler: ${playerName}`;
        updateConnectionStatus("connected");
        retryAttempts = 0;
        return data;
      } catch (err) {
        console.error("Fehler beim Abrufen des Spielernamens:", err);
        document.getElementById("playerNameBanner").innerHTML =
          `Spieler: <span style="color: #ff5555">Verbindungsfehler</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts <= maxRetryAttempts) {
          console.log(`Versuch ${retryAttempts}/${maxRetryAttempts}: Wiederverbinden in 5 Sekunden...`);
          setTimeout(lookupOwnPlayerName, 5000);
        }

        throw err;
      }
    }

    async function monitorGame() {
      if (isPolling) return; // Verhindert parallele Aufrufe
      isPolling = true;
      updateConnectionStatus("polling");

      try {
        const res = await fetch(`/game_state/${gameId}/${playerId}`);
        if (!res.ok) throw new Error(`Server-Fehler: ${res.status}`);

        const data = await res.json();

        // Pr√ºfen, ob das Spiel beendet wurde
        if (data.game_status === "finished") {
          showGameOverScreen(data);
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        // Pr√ºfen, ob Spieler eliminiert wurde
        if (data.status === "eliminated") {
          document.getElementById("gameSection").innerHTML =
            `<div id='errorMessage'>${data.message || "Du wurdest aus dem Spiel entfernt!"}</div>`;
          clearInterval(gamePollingInterval);
          if (votePollingInterval) clearInterval(votePollingInterval);
          updateConnectionStatus("connected");
          return;
        }

        if (!data || data.error) {
          throw new Error(data?.error || "Unbekannter Serverfehler");
        }

        lastGameState = data;

        try {
          // Spielerliste holen
          const playersRes = await fetch(`/players_in_game/${gameId}`);
          if (!playersRes.ok) throw new Error(`Fehler beim Laden der Spielerliste: ${playersRes.status}`);
          const playersData = await playersRes.json();

          // Update UI with game state and players
          updateGameUI(data, playersData);

          // Handle active vote - with enhanced polling
          if (data.active_vote) {
            // Start or continue vote-specific polling if there's an active vote
            checkForActiveVote(data);

            // Start more frequent polling during active votes if not already polling
            if (!votePollingInterval) {
              votePollingInterval = setInterval(async () => {
                try {
                  // Use dedicated vote status endpoint
                  const voteRes = await fetch(`/vote_status/${gameId}/${playerId}`);
                  if (!voteRes.ok) throw new Error(`Fehler beim Abrufen des Vote-Status: ${voteRes.status}`);

                  const voteData = await voteRes.json();
                  if (voteData.active) {
                    // Update vote display with vote status
                    updateVoteDisplay(voteData);
                  } else if (document.getElementById("susOverlay").style.display === "flex") {
                    // If vote is no longer active but overlay is still shown, hide it
                    hideSusOverlay();
                  }
                } catch (err) {
                  console.error("Fehler beim Abrufen des Vote-Status:", err);
                }
              }, 1000); // Poll every second during active votes
            }
          } else {
            // Clear vote polling if no active vote
            if (votePollingInterval) {
              clearInterval(votePollingInterval);
              votePollingInterval = null;
            }

            // Make sure overlay is hidden if no active vote
            if (document.getElementById("susOverlay").style.display === "flex") {
              hideSusOverlay();
            }
          }

          updateConnectionStatus("connected");
          retryAttempts = 0;
        } catch (playersErr) {
          console.error("Fehler beim Laden der Spielerliste:", playersErr);
          // Wir aktualisieren trotzdem die UI mit den verf√ºgbaren Daten
          updateGameUI(data, { players: [] });
          updateConnectionStatus("error");
        }
      } catch (err) {
        console.error("Fehler beim Aktualisieren des Spielstatus:", err);
        document.getElementById("status").innerHTML =
          `<span style="color: #ff5555">Verbindungsfehler: ${err.message}</span>`;

        retryAttempts++;
        updateConnectionStatus("error");

        if (retryAttempts > maxRetryAttempts) {
          console.log(`Zu viele fehlgeschlagene Versuche (${retryAttempts}/${maxRetryAttempts}). Polling wird reduziert.`);
          // Slow down polling when connection is problematic
          if (gamePollingInterval) {
            clearInterval(gamePollingInterval);
            gamePollingInterval = setInterval(monitorGame, 10000); // Poll every 10s instead of 3s
          }
        }
      } finally {
        isPolling = false;
      }
    }

    // Enhanced function to update vote display
    async function updateVoteDisplay(voteData) {
      if (!voteData || !voteData.active) return;

      const isPlayerSuspect = voteData.suspect_id === playerId;
      currentSuspectId = voteData.suspect_id;
      const initiatorName = voteData.initiator_name || "Unbekannt";
      const suspectName = voteData.suspect_name || "Unbekannt";
      const hasVoted = voteData.already_voted;

      // Show overlay if not already shown
      if (document.getElementById("susOverlay").style.display !== "flex") {
        showSusOverlay(initiatorName, suspectName, isPlayerSuspect, hasVoted);
      }

      // Update vote counts
      const upVotes = voteData.votes.up;
      const downVotes = voteData.votes.down;

      // Update or create vote count display
      let countElement = document.querySelector(".vote-count");
      if (!countElement) {
        countElement = document.createElement("div");
        countElement.classList.add("vote-count");
        document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
      }
      countElement.innerHTML = `Stand der Abstimmung: üëç ${upVotes} vs üëé ${downVotes}`;

      // Update votes count text
      document.getElementById("votesCount").textContent = `${voteData.votes_cast}/${voteData.votes_needed}`;

      // Update voter list
      const voterList = document.getElementById("voterList");
      if (voterList) {
        voterList.innerHTML = "";

        // Get all voters and their status
        const voters = voteData.voters || {};

        document.getElementById("voteSummary").classList.remove("hidden");

        // List voters who have voted
        Object.entries(voters).forEach(([voterId, voterInfo]) => {
          const li = document.createElement("li");
          const voteEmoji = voterInfo.vote === "up" ? "üëç" : "üëé";
          li.textContent = `${voterInfo.name}: ${voteEmoji}`;
          li.classList.add(voterInfo.vote === "up" ? "voted-up" : "voted-down");
          voterList.appendChild(li);
        });
      }

      // If vote is complete, update result
      if (voteData.result) {
        // Show the result
        document.getElementById("voteResult").classList.remove("hidden");
        document.querySelector(".vote-btns").style.display = "none";

        // Hide timer
        document.getElementById("voteTimer").classList.add("hidden");

        // Set appropriate result text based on result type
        let resultText = "";
        switch (voteData.result) {
          case "impostor_eliminated":
            resultText = "Der Impostor wurde entfernt! Spiel vorbei!";

            // Show outcome animation for game end
            if (isImpostor) {
              showOutcomeAnimation("VERLOREN!", "Du wurdest als Impostor entlarvt!", "lose");
            } else {
              showOutcomeAnimation("GEWONNEN!", "Ihr habt den Impostor gefunden!", "win");
            }
            break;

          case "impostor_wins":
            resultText = "Der Impostor hat gewonnen!";

            // Show outcome animation for game end
            if (isImpostor) {
              showOutcomeAnimation("GEWONNEN!", "Du hast als Impostor √ºberlebt!", "win");
            } else {
              showOutcomeAnimation("VERLOREN!", "Der Impostor hat √ºberlebt!", "lose");
            }
            break;

          case "player_eliminated":
            // Check if player is impostor to show correct message
            if (voteData.is_player_impostor) {
              resultText = "Ein unschuldiger Spieler wurde entfernt!";

              // Show success message for impostor
              if (isImpostor) {
                showOutcomeAnimation("ERFOLG!", "Ein unschuldiger Spieler wurde entfernt!", "win");
              } else {
                showOutcomeAnimation("OH NEIN!", "Ein unschuldiger Spieler wurde entfernt!", "neutral");
              }
            } else {
              resultText = "Spieler wurde entfernt!";
            }
            break;

          case "vote_failed":
            resultText = "Spieler bleibt im Spiel!";
            break;

          default:
            resultText = "Abstimmung abgeschlossen!";
        }

        document.getElementById("voteResult").innerHTML =
          `${resultText} (üëç ${upVotes} vs üëé ${downVotes})`;
      }

      // Handle overlay hidden flag
      if (voteData.overlay_hidden) {
        hideSusOverlay();
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim L√∂schen des Votings:", err);
          }
        }, 500);
      }
    }

    // Function to show outcome animation
    function showOutcomeAnimation(text, description, type) {
      const animation = document.getElementById("outcomeAnimation");
      const textElem = document.getElementById("outcomeText");
      const descElem = document.getElementById("outcomeDescription");

      animation.classList.remove("hidden");
      textElem.textContent = text;
      descElem.textContent = description;

      // Set appropriate class for styling
      textElem.className = "outcome-text";
      switch (type) {
        case "win":
          textElem.classList.add("outcome-win");
          break;
        case "lose":
          textElem.classList.add("outcome-lose");
          break;
        case "neutral":
          textElem.classList.add("outcome-neutral");
          break;
      }

      // Automatically hide after animation completes
      setTimeout(() => {
        animation.classList.add("hidden");
      }, 7000);
    }

    function showGameOverScreen(data) {
      const isImpostor = data.your_role === "impostor";
      const impostorWon = data.winner === "impostor";
      const secretWord = data.word || data.your_word || "???";

      let message = "";
      let emoji = "";
      let colorClass = "";
      let animationType = "";
      let animationMessage = "";

      if (isImpostor) {
        // Impostor Ende
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Du hast das Wort erraten und gewonnen!";
            animationMessage = "Du hast das geheime Wort erraten!";
          } else {
            message = "Du hast gewonnen! Die Spieler konnten dich nicht finden.";
            animationMessage = "Du hast alle anderen √ºberlebt!";
          }
          emoji = "üèÜ";
          colorClass = "success";
          animationType = "win";
        } else {
          message = "Game Over! Du wurdest entlarvt.";
          animationMessage = "Du wurdest als Impostor entlarvt!";
          emoji = "üö´";
          colorClass = "danger";
          animationType = "lose";
        }
      } else {
        // Normaler Spieler Ende
        if (impostorWon) {
          if (data.end_reason === "word_guessed") {
            message = "Game Over! Der Impostor hat das Wort erraten.";
            animationMessage = "Der Impostor hat das Wort erraten!";
          } else {
            message = "Game Over! Der Impostor hat gewonnen.";
            animationMessage = "Der Impostor hat √ºberlebt!";
          }
          emoji = "üíÄ";
          colorClass = "danger";
          animationType = "lose";
        } else {
          message = "Gratulation! Ihr habt den Impostor gefunden und das Spiel gewonnen!";
          animationMessage = "Der Impostor wurde enttarnt!";
          emoji = "üèÜ";
          colorClass = "success";
          animationType = "win";
        }
      }

      // Show animated outcome
      if (animationType === "win") {
        showOutcomeAnimation("GEWONNEN!", animationMessage, animationType);
      } else {
        showOutcomeAnimation("VERLOREN!", animationMessage, animationType);
      }

      document.getElementById("gameSection").innerHTML = `
        <div class="game-over ${colorClass}">
          <h2>${emoji} Spiel beendet ${emoji}</h2>
          <p>${message}</p>
          <p>Das geheime Wort war: <strong>${secretWord}</strong></p>
          <button onclick="location.reload()">Neu starten</button>
        </div>
      `;
    }

    function updateGameUI(data, playersData) {
      const currentPlayer = data.current_player;
      const isMyTurn = currentPlayer === data.player_name;
      isImpostor = data.your_role === "impostor";

      document.getElementById("turnInfo").innerHTML =
        `üéØ <b>Aktueller Spieler:</b> ${currentPlayer || '-'}`;

      document.getElementById("status").innerHTML = isImpostor
        ? "üïµÔ∏è Du bist der Impostor! Versuche das Wort zu erraten."
        : `üî§ <b>Geheimes Wort:</b> ${data.your_word || '-'}`;

      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      document.getElementById("wordSection").classList.toggle("hidden", !isMyTurn);

      // Spielerliste f√ºr History-Eintr√§ge
      const playerMap = {};
      if (playersData && playersData.players) {
        playersData.players.forEach(p => playerMap[p.player_id] = p.name);
      }

      if (isMyTurn) {
        input.disabled = false;
        input.focus();
        updateSubmitButton();
        setupSusButtons(playersData.players || []);
      } else {
        input.disabled = true;
        btn.disabled = true;
        document.getElementById("susAction").innerHTML = "";
      }

      // History aktualisieren mit verbesserten Anzeigen f√ºr eliminierte Spieler
      const historyContainer = document.getElementById("historyList");
      historyContainer.innerHTML = ""; // Clear existing entries

      // Get eliminated players list
      const eliminatedPlayers = data.eliminated_players || [];

      data.history.forEach(entry => {
        const li = document.createElement("li");

        // Find player name
        const playerName = playerMap[entry.player_id] || entry.player_id;

        // Check if player is eliminated
        const isEliminated = eliminatedPlayers.includes(entry.player_id) ||
            playersData?.players?.find(p => p.player_id === entry.player_id)?.eliminated;

        if (isEliminated) {
          li.innerHTML = `<strike>${playerName}: ${entry.word}</strike>`;
          li.classList.add("eliminated-player");
        } else {
          li.textContent = `${playerName}: ${entry.word}`;
        }

        historyContainer.appendChild(li);
      });
    }

    function checkForActiveVote(data) {
      if (!data.active_vote) {
        // Wenn kein aktives Vote mehr, aber das Overlay ist noch offen
        if (document.getElementById("susOverlay").style.display === "flex" &&
            document.getElementById("voteResult").classList.contains("hidden")) {
          hideSusOverlay();
        }
        return;
      }

      // Pr√ºfen, ob das Overlay f√ºr alle ausgeblendet werden soll
      if (data.active_vote.overlay_hidden) {
        hideSusOverlay();
        // Nach kurzer Verz√∂gerung das Vote komplett l√∂schen
        setTimeout(async () => {
          try {
            await clearVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim L√∂schen des Votings:", err);
          }
        }, 500);
        return;
      }

      const isPlayerSuspect = data.active_vote.suspect_id === playerId;
      currentSuspectId = data.active_vote.suspect_id;

      // Die Namen kommen jetzt direkt vom Server
      const initiatorName = data.active_vote.initiator_name || "Unbekannt";
      const suspectName = data.active_vote.suspect_name || "Unbekannt";

      // Wenn wir das Overlay noch nicht anzeigen oder wenn es ein neues Vote ist
      if (document.getElementById("susOverlay").style.display !== "flex" ||
          document.getElementById("susText").innerText !== `${initiatorName} SUSST ${suspectName}`) {

        // Pr√ºfen ob Spieler bereits abgestimmt hat
        const hasVoted = data.active_vote.votes && data.active_vote.votes[playerId];

        showSusOverlay(initiatorName, suspectName, isPlayerSuspect, hasVoted);
      }

      // Vote-Ergebnisse pr√ºfen, falls sich etwas ge√§ndert hat
      updateVoteResults(data.active_vote);
    }

    function updateVoteResults(voteData) {
      if (!voteData || !voteData.votes) return;

      const votes = voteData.votes;
      let upVotes = 0;
      let downVotes = 0;

      // Stimmen z√§hlen
      Object.values(votes).forEach(vote => {
        if (vote === 'up') upVotes++;
        else if (vote === 'down') downVotes++;
      });

      // Update vote count display
      let countElement = document.querySelector(".vote-count");
      if (!countElement) {
        countElement = document.createElement("div");
        countElement.classList.add("vote-count");
        document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
      }
      countElement.innerHTML = `Stand der Abstimmung: üëç ${upVotes} vs üëé ${downVotes}`;

      // Wenn Abstimmung bereits abgeschlossen ist
      if (voteData.result) {
        document.getElementById("voteResult").classList.remove("hidden");
        document.querySelector(".vote-btns").style.display = "none";

        // Hide timer
        document.getElementById("voteTimer").classList.add("hidden");

        let resultText = "";
        switch (voteData.result) {
          case "impostor_eliminated":
            resultText = "Der Impostor wurde entfernt! Spiel vorbei!";
            break;
          case "impostor_wins":
            resultText = "Der Impostor hat gewonnen!";
            break;
          case "player_eliminated":
            resultText = "Spieler wurde entfernt!";
            break;
          case "vote_failed":
            resultText = "Spieler bleibt im Spiel!";
            break;
          default:
            resultText = "Abstimmung abgeschlossen!";
        }

        document.getElementById("voteResult").innerHTML = resultText;

        // Overlay nach kurzer Verz√∂gerung ausblenden, wenn das Ergebnis da ist
        setTimeout(async () => {
          // Vote auf dem Server markieren, dass das Overlay bei allen ausgeblendet werden soll
          try {
            await endVoteWithRetry();
          } catch (err) {
            console.error("Fehler beim Beenden des Votings:", err);
          }
        }, 3000);
      }
    }

    // Function to retry clearing vote
    async function clearVoteWithRetry(maxRetries = 3) {
      let attempts = 0;

      while (attempts < maxRetries) {
        try {
          const res = await fetch("/clear_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_id: gameId })
          });

          if (!res.ok) throw new Error(`Server error: ${res.status}`);

          console.log("Vote successfully cleared");
          await monitorGame(); // Refresh game state
          return;
        } catch (err) {
          console.error(`Failed to clear vote (attempt ${attempts + 1}/${maxRetries}):`, err);
          attempts++;

          if (attempts < maxRetries) {
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
          } else {
            throw err; // Rethrow if all attempts failed
          }
        }
      }
    }

    // Function to retry ending vote
    async function endVoteWithRetry(maxRetries = 3) {
      let attempts = 0;

      while (attempts < maxRetries) {
        try {
          const res = await fetch("/end_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_id: gameId })
          });

          if (!res.ok) throw new Error(`Server error: ${res.status}`);

          console.log("Vote ending marked");
          await monitorGame(); // Refresh game state
          return;
        } catch (err) {
          console.error(`Failed to end vote (attempt ${attempts + 1}/${maxRetries}):`, err);
          attempts++;

          if (attempts < maxRetries) {
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
          } else {
            throw err; // Rethrow if all attempts failed
          }
        }
      }
    }

    function updateSubmitButton() {
      const input = document.getElementById("hint");
      const btn = document.getElementById("submitBtn");
      const errorMsg = document.getElementById("errorMessage");
      const charCount = document.getElementById("charCount");

      const word = input.value.trim();
      charCount.textContent = word.length;

      if (word.length === 0) {
        btn.disabled = true;
        errorMsg.classList.add("hidden");
        return;
      }

      if (!/^[\w√§√∂√º√Ñ√ñ√ú√ü]+$/.test(word)) {
        btn.disabled = true;
        errorMsg.innerText = "Bitte nur Buchstaben und Zahlen verwenden";
        errorMsg.classList.remove("hidden");
        return;
      }

      errorMsg.classList.add("hidden");
      btn.disabled = false;
      btn.onclick = () => submitWord(word);
    }

    document.getElementById("hint").addEventListener("input", updateSubmitButton);

    async function submitWord(word) {
      if (!word) return;

      const btn = document.getElementById("submitBtn");
      const originalText = btn.innerHTML;
      btn.innerHTML = "Wird gesendet... <span class='loading'></span>";
      btn.disabled = true;

      try {
        const res = await fetch(`/submit_word`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            game_id: gameId,
            player_id: playerId,
            word: word.trim()
          })
        });

        if (!res.ok) {
          throw new Error(`Server-Fehler: ${res.status}`);
        }

        document.getElementById("hint").value = "";
        document.getElementById("charCount").textContent = "0";
        await monitorGame();
      } catch (err) {
        console.error("Fehler beim Senden des Wortes:", err);
        const errorMsg = document.getElementById("errorMessage");
        errorMsg.innerText = `Fehler beim Senden: ${err.message}`;
        errorMsg.classList.remove("hidden");
      } finally {
        btn.innerHTML = originalText;
        updateSubmitButton();
      }
    }

    function setupSusButtons(players) {
      if (!players || !Array.isArray(players) || players.length === 0) {
        console.warn("[setupSusButtons] Keine Spieler gefunden");
        return;
      }

      // Nur aktive Spieler anzeigen (nicht eliminierte)
      const suspects = players.filter(p =>
        p.player_id !== playerId &&
        !p.eliminated &&
        !lastGameState?.eliminated_players?.includes(p.player_id)
      );

      const container = document.getElementById("susAction");
      container.innerHTML = "<label>üïµÔ∏è Verd√§chtigen:</label><br>";

      if (suspects.length === 0) {
        container.innerHTML += "<p>Keine weiteren Spieler verf√ºgbar!</p>";
        return;
      }

      suspects.forEach(p => {
        const btn = document.createElement("button");
        btn.textContent = `SUS ${p.name}`;
        btn.onclick = () => {
          if (!isVoting) startVote(p.player_id, p.name);
        };
        container.appendChild(btn);
      });
    }

    async function startVote(suspectId, suspectName) {
      if (isVoting) return; // Verhindert mehrfache Votes
      isVoting = true;

      let retryCount = 0;
      const maxRetries = 3;
      const targetButton = event.target;
      const originalText = targetButton.textContent;

      targetButton.textContent = `SUS wird gestartet...`;
      targetButton.disabled = true;

      async function attemptStartVote() {
        try {
          updateConnectionStatus("polling");
          const res = await fetch("/start_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: gameId,
              initiator_id: playerId,
              suspect_id: suspectId
            })
          });

          if (!res.ok) {
            throw new Error(`Server-Fehler: ${res.status}`);
          }

          const data = await res.json();
          if (data.status === "vote_started") {
            // Wir verwenden die Namen aus der Serverantwort
            currentSuspectId = suspectId;
            const initiatorName = data.initiator_name || playerName;
            const suspectName = data.suspect_name || "Unbekannt";

            console.log("Vote gestartet:", {
              initiatorName,
              suspectName
            });

            showSusOverlay(initiatorName, suspectName, false, false);
            updateConnectionStatus("connected");
          } else {
            throw new Error(data.error || "Unbekannter Fehler");
          }

          // Button zur√ºcksetzen
          targetButton.textContent = originalText;
          targetButton.disabled = false;
        } catch (err) {
          console.error(`Fehler beim Starten des Votes (Versuch ${retryCount + 1}/${maxRetries}):`, err);

          if (retryCount < maxRetries) {
            retryCount++;
            targetButton.textContent = `Erneuter Versuch (${retryCount})...`;
            updateConnectionStatus("error");
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, 1000));
            await attemptStartVote();
          } else {
            console.error("Failed to start vote after retries");
            alert(`Fehler beim Starten des Votes: ${err.message}`);
            targetButton.textContent = originalText;
            targetButton.disabled = false;
            updateConnectionStatus("error");
          }
        }
      }

      await attemptStartVote();
      isVoting = false;
    }

    function showSusOverlay(from, to, isPlayerSuspect, hasVoted) {
      console.log("[SUS] Overlay anzeigen:", from, "susst", to, "isPlayerSuspect:", isPlayerSuspect, "hasVoted:", hasVoted);

      // Text im Overlay setzen
      document.getElementById("susText").innerText = `${from} SUSST ${to}`;
      document.getElementById("susOverlay").style.display = "flex";

      // Vorbereitung f√ºr die Vote-Anzeige
      document.getElementById("voteResult").classList.add("hidden");

      // Das X zum Schlie√üen anzeigen/verstecken
      document.getElementById("closeVote").classList.toggle("hidden", isPlayerSuspect);

      // Vote-Buttons nur anzeigen, wenn der Spieler nicht der Verd√§chtige ist und noch nicht abgestimmt hat
      if (isPlayerSuspect) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du wirst verd√§chtigt! Warte auf die Abstimmung...";
      } else if (hasVoted) {
        document.querySelector(".vote-btns").style.display = "none";
        document.getElementById("voteResult").classList.remove("hidden");
        document.getElementById("voteResult").innerHTML = "Du hast bereits abgestimmt!";
      } else {
        document.querySelector(".vote-btns").style.display = "flex";
        document.getElementById("voteUpBtn").disabled = false;
        document.getElementById("voteDownBtn").disabled = false;
      }

      // Show vote timer
      const timerElem = document.getElementById("voteTimer");
      timerElem.classList.remove("hidden");

      // Start countdown timer (15 seconds)
      let secondsLeft = 15;
      const countdown = setInterval(() => {
        secondsLeft--;

        if (secondsLeft <= 0) {
          clearInterval(countdown);
          timerElem.innerHTML = "Abstimmung wird ausgewertet...";
        } else {
          timerElem.innerHTML = `Zeit zum Abstimmen: ${secondsLeft}s`;

          // Visual urgency
          if (secondsLeft <= 5) {
            timerElem.style.color = "red";
            timerElem.style.fontWeight = "bold";
          }
        }
      }, 1000);

      // Store timer reference to clear it if needed
      window.voteTimer = countdown;

      // Initialize empty voter list
      document.getElementById("voteSummary").classList.remove("hidden");
      document.getElementById("voterList").innerHTML = "";
    }

    function hideSusOverlay() {
      document.getElementById("susOverlay").style.display = "none";
      document.getElementById("voteResult").classList.add("hidden");
      document.getElementById("voteSummary").classList.add("hidden");
      document.getElementById("voteTimer").classList.add("hidden");
      currentSuspectId = null;

      // Clear timer if exists
      if (window.voteTimer) {
        clearInterval(window.voteTimer);
        window.voteTimer = null;
      }
    }

    document.getElementById("closeVote").addEventListener("click", hideSusOverlay);

    async function castVote(vote) {
      // Pr√ºfen ob der Spieler der Verd√§chtigte ist
      if (currentSuspectId === playerId) {
        alert("Du kannst nicht √ºber dich selbst abstimmen!");
        return;
      }

      const upBtn = document.getElementById("voteUpBtn");
      const downBtn = document.getElementById("voteDownBtn");
      upBtn.disabled = true;
      downBtn.disabled = true;

      const clickedBtn = vote === 'up' ? upBtn : downBtn;
      const originalHTML = clickedBtn.innerHTML;
      clickedBtn.innerHTML = `<span class='loading'></span>`;

      let retryCount = 0;
      const maxRetries = 3;

      async function attemptCastVote() {
        try {
          updateConnectionStatus("polling");
          const res = await fetch("/cast_vote", {
            method: "POST",
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              game_id: gameId,
              voter_id: playerId,
              vote
            })
          });

          if (!res.ok) {
            throw new Error(`Server-Fehler: ${res.status}`);
          }

          const data = await res.json();

          // Update UI with vote information
          document.querySelector(".vote-btns").style.display = "none";
          document.getElementById("voteResult").classList.remove("hidden");

          // Update vote count information immediately, even if not all have voted
          if (data.up_votes !== undefined && data.down_votes !== undefined) {
            let countElement = document.querySelector(".vote-count");
            if (!countElement) {
              countElement = document.createElement("div");
              countElement.classList.add("vote-count");
              document.getElementById("voteResult").insertAdjacentElement('beforebegin', countElement);
            }
            countElement.innerHTML = `Stand der Abstimmung: üëç ${data.up_votes} vs üëé ${data.down_votes}`;

            // Update votes count text
            document.getElementById("votesCount").textContent = `${data.total_votes}/${data.total_possible_votes}`;
          }

          // Wenn die Abstimmung abgeschlossen ist
          if (data.status === "vote_completed") {
            let resultText = getVoteResultText(data.result);
            document.getElementById("voteResult").innerHTML =
              `${resultText} (üëç ${data.up_votes} vs üëé ${data.down_votes})`;

            // Show outcome animation based on result
            if (data.result === "impostor_eliminated") {
              if (isImpostor) {
                showOutcomeAnimation("VERLOREN!", "Du wurdest als Impostor entlarvt!", "lose");
              } else {
                showOutcomeAnimation("GEWONNEN!", "Ihr habt den Impostor gefunden!", "win");
              }
            } else if (data.result === "impostor_wins") {
              if (isImpostor) {
                showOutcomeAnimation("GEWONNEN!", "Du hast als Impostor √ºberlebt!", "win");
              } else {
                showOutcomeAnimation("VERLOREN!", "Der Impostor hat √ºberlebt!", "lose");
              }
            } else if (data.result === "player_eliminated") {
              // Show outcome based on player role
              if (isImpostor) {
                showOutcomeAnimation("ERFOLG!", "Ein unschuldiger Spieler wurde entfernt!", "win");
              } else {
                showOutcomeAnimation("OH NEIN!", "Ein unschuldiger Spieler wurde entfernt!", "neutral");
              }
            }
          } else {
            document.getElementById("voteResult").innerHTML = "Danke f√ºr dein Vote!";
          }

          // Spielstatus aktualisieren
          await monitorGame();
          updateConnectionStatus("connected");
        } catch (err) {
          console.error(`Fehler beim Abstimmen (Versuch ${retryCount + 1}/${maxRetries}):`, err);

          if (retryCount < maxRetries) {
            retryCount++;
            // Show retry attempt
            clickedBtn.innerHTML = `Erneuter Versuch (${retryCount})...`;
            updateConnectionStatus("error");
            // Wait before retrying
            await new Promise(resolve => setTimeout(resolve, 1000));
            await attemptCastVote();
          } else {
            console.error("Failed to cast vote after retries");
            clickedBtn.innerHTML = originalHTML;
            upBtn.disabled = false;
            downBtn.disabled = false;
            alert(`Fehler beim Abstimmen: ${err.message}`);
            updateConnectionStatus("error");
          }
        }
      }

      await attemptCastVote();
    }

    function getVoteResultText(result) {
      switch (result) {
        case "impostor_eliminated": return "Der Impostor wurde entfernt! Spiel vorbei!";
        case "impostor_wins": return "Der Impostor hat gewonnen!";
        case "player_eliminated": return "Spieler wurde entfernt!";
        case "vote_failed": return "Spieler bleibt im Spiel!";
        default: return "Abstimmung abgeschlossen!";
      }
    }

    // Event-Listener f√ºr die Seite
    window.addEventListener("beforeunload", () => {
      if (gamePollingInterval) clearInterval(gamePollingInterval);
      if (votePollingInterval) clearInterval(votePollingInterval);
    });
  </script>
</body>
</html>